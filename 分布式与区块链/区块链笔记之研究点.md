# 区块链笔记之研究点
---
- 可扩展与速度
    - 闪电网络
    - 雷电网络
    - Plasma
    - 分片
    - DAG
- 共识
    - 共识算法切换
        - Casper
    - 改进成新的共识算法
- 通信
    - 跨链通信
- 持久化
- BaaS
    - 信任问题
        - 对租赁者的信任
        - 对服务提供方的信任
    - 权限管理和监管问题：因为大部分使用的是联盟链
        - 现有算法的改进
        - 新的权限管理算法
    - 解耦问题：共识算法和隐私管理算法等可以随意组合

---
# 可扩展与速度
## 闪电网络
### 概述
一种利用链下支付通道网络实现比特币扩容的技术。把链上的绝大多数交易转移至链外处理，允许用户通过私下交换转账签名信息实现交易，从而大幅度增加交易处理速度。

闪电网络提供了一个可扩展的微支付通道网络。交易双方若在区块链上预先设有支付通道，就可以多次、高频、双向地通过轧差方式实现瞬间确认的微支付；双方若无直接的点对点支付通道，只要网络中存在一条连通双方的、由多个支付通道构成的支付路径，闪电网络也可以利用这条支付路径实现资金在双方之间的可靠转移

### 闪电网络技术本质
闪电网络的关键技术有三，后后依赖于前前，依次是：RSMC，HTLC和闪电网络。技术实现虽然复杂，但本质却很简单。

#### RSMC(Recoverable Sequence Maturity Contract，序列到期可撤销合约)
闪电网络的基础是交易双方之间的双向微支付通道，RSMC定义了该双向微支付通道的最基本工作方式。

闪电网络中，参加交易方共同维护一个微支付通道，交易方预先向通道中注入一笔资金，同时通道记录有双方对资金的分配方案。假如参加交易方有两个：Alice和Bob，他们分别向同道中注入0.4BTC和0.6BTC，通道刚设立时，初值是{Alice: 0.4, Bob: 0.6}，意味着打入通道的资金共有1.0 BTC，其中Alice拥有0.4 BTC，Bob拥有0.6 BTC。通道的设立会记录在比特币区块链上。

假设稍后Bob决定向Alice支付0.1 BTC。双方在链下对最新余额分配方案{Alice:0.5, Bob:0.5} 签字认可，并签字同意作废前一版本的余额分配方案{Alice:0.4, Bob:0.6}，Alice就实际获得了0.5 BTC的控制权，分配方案变为：{Alice:0.5, Bob:0.5}。
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_90.png">
</center>

如果Alice暂时不需要将通道中现在属于她的0.5 BTC用作支付，她可以无需及时更新区块链上记录的通道余额分配方案，因为很可能一分钟后Alice又需要反过来向Bob支付0.1 BTC，此时他们仍然只需在链下对新的余额分配方案达成一致，并设法作废前一版本的余额分配方案就行了。

如果Alice打算终止通道并动用她的那份资金，她可以向区块链出示双方签字的余额分配方案。如果一段时间之内Bob不提出异议，区块链会终止通道并将资金按协议转入各自预先设立的提现地址。如果Bob能在这段时间内提交证据证明Alice企图使用的是一个双方已同意作废的余额分配方案，则Alice的资金将被罚没并给到Bob。

实际上，前面所说的“作废前一版本的余额分配”，正是通过构建适当的“举证”证据并结合罚没机制实现的。

为了鼓励双方尽可能久地利用通道进行交易，RSMC对主动终止通道方给予了一定的惩罚：主动提出方其资金到账将比对方晚，因此谁发起谁吃亏。这个设计虽然增加了技术复杂度，但应该说是合理的。

上述过程中只有两个操作需要上链：**通道建立**和**通道解除**，这样就大大减少了链上负担。

#### HTLC（Hashed Timelock Contract，哈希时间锁定协议）
 RSMC只支持最简单的无条件资金支付，HTLC（Hashed Timelock Contract）进一步实现了有条件的资金支付，通道余额的分配方式也因此变得更为复杂。

通过HTLC，Alice和Bob可以达成这样一个协议：协议将锁定Alice的0.1 BTC，在时刻T到来之前（T以未来的某个区块链高度表述），如果Bob能够向Alice出示一个适当的R（称为秘密），使得R的哈希值等于事先约定的值H(R)，Bob就能获得这0.1 BTC；如果直到时刻T过去Bob仍然未能提供一个正确的R，这0.1 BTC将自动解冻并归还Alice。

由于到期时间T、提款条件H(R)、支付金额、支付方向的不同，同一个通道上可以同时存在多个活动的HTLC合约，加上唯一的通过RSMC协议商定的无条件资金余额，余额分配方式会变得相当复杂。假设双方初始各存入0.5 BTC，一段时间后余额分配可能这样：
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_91.png">
</center>

余额分配方案是一种快照，只能整体刷新。接上表，如果Alice下一刻决定无条件向Bob支付0.1 BTC，或者Alice在T1前向Bob出示了符合H(R1)的秘密，双方将在链下交换并共同签字认定新的快照，然后构建适当的“举证”证据，结合罚没机制作废前一版本的快照。这些动作完全不出现在区块链上。 引入HTLC后，任何一方仍然能通过在区块链上公开最终余额快照的方式终止通道。

哈希时间锁定协议使得转账更为方便，只需要提供秘密即可。

#### 闪电网络
基于HTLC可以实现终极目标“闪电网络”。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_92.png">
</center>

如上图所示，Alice想给Dave发送0.05 BTC，但Alice和Dave之间并没有微支付通道。但这没关系，Alice找到了一条经过Bob、Carol到达Dave的支付路径，该路径由Alice/Bob, Bob/Carol和Carol/Dave这样三个微支付通道串接而成。
Dave生成一个秘密R并将Hash(R)发送给Alice，Alice不需要知道R。R和Hash(R)的作用就像是古代调兵用的一对虎符。

Alice和Bob商定一个HTLC合约：只要Bob能在3天内向Alice出示哈希正确的R，Alice会支付Bob 0.052 BTC；如果Bob做不到这点，这笔钱3天后自动退还Alice。

同样地，Bob和Carol商定一个HTLC合约：只要Carol能在2天内向Bob出示哈希正确的R，Bob会支付Carol 0.051 BTC；如果Carol做不到这点，这笔钱到期自动退还Bob。

最后，Carol和Dave商定一个HTLC合约：只要Dave能在1天内向Carol出示哈希正确的R，Carol会支付Dave 0.05 BTC；如果Dave做不到这点，这笔钱到期自动退还Carol。

一切就绪后，Dave及时向Carol披露R并拿到0.05 BTC；现在Carol知道了R，她可以向Bob出示密码R并拿到0.051 BTC（差额部分的0.001 BTC成了Carol的佣金）；Bob知道R后当然会向Alice出示并拿到他的那份0.052 BTC，差额部分的0.001 BTC成了Bob的佣金。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_93.png">
</center>

整个过程很容易理解。最终效果是Alice支付了0.052 BTC，Dave安全地拿到0.05 BTC，整个闪电支付网络为此收取的佣金成本是0.002 BTC。上述过程中的全部动作都发生在比特币区块链之外。
尽管闪电网络本身可以基于任何合适的传统技术构建，闪电网络的支付通道也可能逐渐向少数大型中介集中，变成若干大型中介彼此互联、普通用户直连大型中介的形式，但这种方案仍然具有传统中心化方案不可比拟的优势，因为用户现在并不需要信任中介，不需要在中介处存钱才能转移支付，资金安全受到比特币区块链的充分保护。

## 雷电网络（Raiden Network）
Raiden项目的思路直接继承自比特币闪电网络，但也有所发展。因为以太坊智能合约对报文格式没有特别的字段限制，使得Raiden得以为通道余额快照引入一个单增序号，极为轻松自然地解决了旧版本快照的识别和作废问题。 首先要在以太坊上建有一个智能合约，由此智能合约处理下文提到的OpenTransaction、UpdateTransaction等指令。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_94.png" width="500">
</center>

和闪电网络一样，双方需要在以太坊区块链上开设通道并各自锁定以太。这步动作可通过向Raiden智能合约发送一条双方签名认可的报文来实现。报文中的关键信息包括：双方公钥、双方锁定资产数量、双方签名。
此后的任何支付动作都可以发生在以太坊区块链外，参与双方只需要私下传递一系列报文，其中最重要的报文是UpdateTransaction，其形式如下。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_95.png" width="500">
</center>

此报文的内容几乎就是闪电网络的通道余额分配方案的翻版，只有几处细微的差别：
>- 一是增加了Sequence Number字段和Hold Period字段以便识别作废的报文。A如果向区块链上合约提交一个双方签字的UpdateTransaction报文，合约将等待Hold Period时间。期间如果对手方B能够提交一个Sequence Number更高的UpdateTransaction报文，合约将没收A质押在通道中的全部资产并转移给B。如果直至等待超时B也没有异议，合约将按照报文内容在区块链上完成转移支付并关闭通道。
>- 二是通过Net Transfer Amount隐含余额分配的方式和闪电网络略有不同，这里的方式是从建立通道时申明的Amount 1中扣减Net Transfer Amount，再将之加到Amount 2上。和直接申明余额比只是形式上的差别。
>- 三是雷电中引入了较HTLC更为通用的“Smart Condition”。Smart Condition表现为一个可在区块链上执行的函数Function(argument)，可接受任何格式的报文为参数，执行后返回一个[0, 1]之间的数。将其返回值乘以配套的Condition Transfer Amount，再加到Net Transfer Amount上去，就完成了条件支付引发的余额调整。闪电网络中的所谓hash lock，现在成了Smart Condition的一个特例。Smart Condition能够提供远较哈希校验丰富的功能，比如可以根据某类ORACLE提供的道琼斯指数值完成衍生品合约的自动执行。
当发生争议时，只需向区块链上智能合约出示最新版本的UpdateTransaction报文，并请求智能合约对报文中的Smart Condition予以处理，就可以强制执行合约。如果没有争议，以上这一切都不会出现在以太坊区块链上，增强了隐私，又提升了性能。

其他设计思路，如通过多跳打通微支付通道、接收方提交适当的argument作为提款凭证等都和闪电网络类似。

##  比特币闪电网络技术剖析
### 1. 说明
闪电网络的原始论文非常难懂，很大一部分困难可能来自作者使用的图例的形式不够直观，且缺乏明确的说明。笔者将尝试使用一套新的图例，希望能够极大降低理解难度。

本文将详细剖析闪电网络所用交易结构，但不能完全代替原始论文。
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_96.png" width="500">
图1 比特币交易图例
</center>

图1展示了一个拥有2个输入、3个输出、保存在链下的比特币交易记录，以下逐一说明其中要素。
圆角矩形代表“交易”，用不同的底色区分交易持有者，本文一律用玫红色表示Alice，浅蓝色表示Bob。圆角矩形的边框用细实线勾勒，表示该笔交易并未公布在区块链上。

论文中每笔交易都有一个名称，虽然比特币交易结构并没有这样一个字段。我们选择将交易名称写在圆角矩形上半部，上图中“txnName”就是这个名称。

闪电网络需要在比特币交易结构中的sequence字段和locktime字段填入适当的值，将其写在圆角矩形的下半部，如上图中的“seq = 1000”。 “0.55、0.35、0.3、0.4、0.2”都是交易输出金额。虽然“0.55和0.35”边上的箭头代表交易输入，但交易输入一定是另一交易的输出，所以这样表达仍然合理。

“0.3、0.4、0.2”边上的箭头代表交易输出。“#0, #1, #2”代表输出序号。

金额为0.3的交易输出旁边写有“（B）”，表示该笔交易输出需用B的私钥解锁。

金额为0.55的交易输入旁边写有“（C）”，意思一样，表示需动用C的私钥解锁对应交易输出。在“（C）”的右上方打有一钩（√），表示对应解锁条件已就绪。此钩颜色是绿色，表示此解锁脚本在交易拥有者拿到手时就已就绪。

“（A, B, H(R)）”代表一个特殊的解锁条件，需要同时提供A和B的私钥签名，并且需要提供一个合适的R，令其哈希值等于预设的H(R)值，才能解锁交易输出。图中A、B右上角都打有绿色的钩，表明对应解锁条件已就绪。H(R)右上角没有任何钩，表明合适的R尚未出现。

接下来我们为这笔交易提供正确的R值，并将就绪后的交易在区块链上公布，对应图例就变成这样： 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_97.png" width="500">
图2 解锁R并公布在区块链上的交易
</center>

注意H(R)右上方出现了红色的钩，表明对应解锁条件变为就绪。圆角矩形框的边框变成宽实线，表明这笔交易已公布在区块链上。
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_98.png" width="600">
图3 互斥的交易
</center>

闪电网络允许在链下并存多个消费同一交易输出的不同交易。如果将这些交易都发布到区块链上，显然只有其中一个交易能够生效，其他交易都因为不能双花被拒绝了。上图用一个带“X”的圆圈表达了C1a、C1b的互斥关系。
HTLC中会使用IF…ELSE…ENDIF结构的加锁脚本，就长这样子：
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_99.png" width="600">
图4 IF…ELSE…ENDIF脚本
</center>

其中一个分支通过提供Alice2、Bob2的签名和R解锁，另一个分支只需提供Alice1、Bob2的签名就可以解锁。为特别表明此处用到了IF结构，在图例中我们会在表达互斥的带“X”圆圈旁边加注“if”，就像下图一样： 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_100.png" width="600">
图5 if语句带来的互斥交易
</center>

### 2. RSMC剖析
#### 2.1 通道建立
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_101.png" width="600">
图6 通道建立
</center>

通道建立只需要双方在链下准备一套类似上图的交易结构，完成后仅将funding交易发布到区块链上（注意粗实线的边框）。上图中的A代表Alice,B代表Bob。
虽然本例中双方都向通道注资0.5 BTC，但其实各自注入多少都是可以的，不强求相等或大于0。

之所以要完全准备就绪这套交易结构后才能发布funding交易，是为了避免先发布funding交易后一方拒绝配合完成其余交易的准备活动。由于funding交易唯一的输出要求同时使用A/B双方的私钥签字才能提取，一方拒绝配合签名将导致这部分资金永久无法支取。所以合理的顺序是先准备就绪全套交易，再发布funding交易。

上图中，交易C1a虽然为Alice持有（玫红底色），但其输入解锁脚本中B已就绪，因此这条交易记录实际上是Bob准备好后给到Alice的，因为除了Bob没人能够做到这一点。C1b的输入解锁脚本中A也已就绪，说明交易记录C1b是Alice准备好后给到Bob的。

图中，交易RD1a和RD1b上都标注了“seq=1000”，这是比特币交易结构的一个最新特性，sequence字段如此设置后，交易RD1a只能在包含其父交易C1a的区块得到1000个确认后才能被收录。

#### 2.2 单方面终止通道
通道建立后，Alice或Bob随时可以选择单方面终止通道并取回资金，发起方将受到延迟提款的惩罚。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_102.png" width="600">
图7 Alice单方面终止通道
</center>

Alice单方面终止通道的方式如下：Alice为C1a和RD1a的输入解锁脚本用自己的私钥签名，并在区块链上发布交易C1a。由于RD1a的seq = 1000，他必须等待C1a被收录并得到1000个确认后才能发布交易RD1a，因此他需要等上10,000分钟（约7天）才能通过RD1a取回自己的款。对Bob来说，他只需要在区块链上看到C1a发布，随时可以用自己的私钥动用C1a的0号输出的资金。最终双方都得到0.5 BTC，funding交易的输出被提取一空，通道终止。

图中用粗黑有向线条表达了区块链上实际的资金流向。

2.3 微支付及旧版本废止
在双方各占0.5 BTC的基础上，Alice向Bob支付0.1 BTC，双方余额应该调整为Alice 0.4 BTC，Bob 0.6 BTC。

为此需要创建余额的新版本，然后废止余额的旧版本。由于比特币的交易由一个个离散的utxo构成，也没有多余的字段存放“版本号”，所以是迂回地通过经济手段来达到实际废止的效果。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_103.png" width="600">
图8 微支付：创建新版本余额
</center>

创建余额的新版本很简单，双方完全不动区块链上的funding交易，在链下按上图另外创建一套反映新余额的交易。很清楚，现在Alice实际控制0.4 BTC而Bob实际控制0.6 BTC，等价于Alice支付Bob 0.1 BTC。注意为便于区分，交易名称都改变了。
作废旧版本的余额非常有技巧，方法是在旧版本交易的基础上增加几个作恶惩戒交易，效果上类似发誓：“我要是拿这个旧版本去区块链上提款，你就把我的那份拿走！”，只不过这个誓言是决定可以生效的。
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_104.png" width="700">
图9 微支付：作废旧版本余额
</center>

C1a, C1b, RD1a, RD1b都是旧版本余额用到的交易。作废这堆交易的方式是构造一对新的交易BR1a和BR1b，并准备就绪其输入解锁脚本所需全部签名。上图中，红色虚线框中的两笔交易是在原来基础上新增构建的。
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_105.png" width="700">
图10 微支付：惩罚措施
</center>

在图9的基础上，如果Alice希望通过在区块链上通过发布旧版本余额对应的交易来逆转刚才支付给Bob的0.1 BTC，她将受到惩罚，原理见上图。
Alice为C1a的输入解锁脚本补上自己的签名，发布到区块链上。因为交易RD1a有seq=1000的属性设定，所以Alice暂时还不能发布RD1a。但Bob将看到承诺作废的C1a被放出，为保护自身利益，Bob可以立刻在区块链上发布交易BR1a，因为BR1a的父交易已被放出，且BR1a的输入解锁脚本早已就绪，所以BR1a可以马上生效，于是Bob一共可以拿走1.0 BTC，企图作恶的Alice偷鸡不成。

正常情况下，Alice只要不在区块链上发布C1a，虽然Bob拥有输入解锁脚本完全就绪的BR1a，因为其父交易C1a并未发布，Bob也无法发布BR1a。这说明只要一方安分守己，就无需担心惩罚措施。

## HTLC剖析
### 3.1 初始化HTLC
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_106.png" width="800">
图11 HTLC的初始化
</center>

图11给出的是一个简单的HTLC示例，其所反映的通道余额划分是：有0.9 BTC以无条件余额划分的形式在Alice和Bob之间分割，Alice占0.4 BTC，Bob占0.5 BTC。Alice向Bob有条件支付0.1 BTC，如果Bob能于3天内（实际是以区块链高度代表的未来某时）之前提供合适的R，Bob就能得到这笔钱，反之这笔钱仍然回到Alice账上。
这里的“> 3 days”是利用locktime字段的最新扩展实现的。和“seq=1000”的区别在于：locktime指定的是一个高度绝对值，而sequence指定的是相对父交易所在区块高度的相对值。

由于要在一个通道上同时反映无条件余额划分和有条件支付，所以交易结构变得相当复杂。图10中，C2a, RD2a, D2a, C2b, RD2b, D2b通过RSMC实现无条件余额划分，最下方的6笔交易专门用于HTLC支付。
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_107.png" width="800">
图12 HTLC：Bob及时提交R
</center>

如果Bob能够在3天内及时提交R，他可以如图11所示，准备好一系列交易的输入解锁脚本（注意图中红色的“√”）后将C2b、RD2b、HE1b及HERD1b交易发布到区块链上，拿走0.5+0.1 BTC。Alice此时只能跟着发布交易D2b拿走自己的0.4 BTC，通道终止。 也可以不终止通道，关键在于只要Bob离线告知Alice他拥有适当的R，且双方愿意达成新版本的余额划分，那么只需要新建一个Alice 0.4 BTC、Bob 0.6 BTC的新版本余额并废止旧版本，效果上就等于这0.1 BTC的条件支付已经达成。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_108.png" width="800">
图13 HTLC: 超时退款
</center>

如果直到超时Bob仍不能提供正确的R值，Alice可以如图12所示，通过用自己的私钥准备各交易的输入解锁脚本并发布交易到区块链上，最终取回这0.1 BTC（注意图中红色的“√”），。在此方式下，最终Alice拿到0.5 BTC，Bob拿到0.5 BTC。和图11完全类似，也可以采用新建版本余额的方式，无需终止通道。

### 作废旧版本与违约惩罚
建立新版本余额快照后，就应该作废旧版本。和之前作废旧版本的思路类似，在通道中还包含HTLC合约的情况下，依然靠新增若干作恶惩戒交易的方式作废旧版本。 
<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_109.png" width="900">
图14 作废旧版本余额
</center>

图14中用红色虚线框出的部分就是新增的“作恶惩戒交易”。

<center>
<img src="https://cdn.8btc.com/wp-content/uploads/2016/06/Snip20160612_110.png" width="800">
图15 惩戒交易示意
</center>

在图15中，假设HT1a交易已经超时，但以C2a为根的全部交易都已通过惩戒交易予以作废。如果此时Alice想作恶，她将C2a、RD2a、HT1a及HTRD1a的输入解锁脚本用自己的私钥准备就绪后（注意图中红“√”），将交易C2a和交易HT1a在区块链上公开。由于seq字段的限制，她不能立刻公开交易RD2a和HTRD1a，这样就使得Bob有机会发现Alice企图作恶并能够通过公布BR2a和HTBR1a交易的方式予以惩戒。发出这对交易后，通道中的全部资金将都归Bob所有。
图15中虽然没有用上惩戒交易HBR1a，但该交易并不多余。理由是：如果Alice在区块链上公布了交易C2a但故意不公布交易HT1a，倘若Bob手头没有HBR1a，也不知道秘密R，Bob将无法获得这0.1 BTC。有了惩戒交易HBR1a之后，即使Alice不公布交易HT1a，只要C2a公布，Bob也可以通过HBR1a顺利提取这0.1 BTC。

只提供HBR1a、不提供HTBR1a也是不行的。因为万一Alice选择的是解锁并公布交易HT1a，并且抢在Bob之前消费了C2a的#2输出，Bob拥有的HBR1a交易就无法生效了，而此时虽然HTRD1a交易要等上1000个确认才能公布，Bob也没有任何手段来利用这1000个块的确认时间来阻止Alice提取这0.1 BTC。

## 闪电网络的缺点
>- 转账成功率不高。
>- 安全性。用户的资金可能会被闪电网络的节点窃取。
>- 闪电网络的钱包必须总保持在线。

## 参考
>- http://www.tucaod.com/1962.html
>- https://blog.csdn.net/qq_30634311/article/details/80851962
>- https://www.8btc.com/article/267084
>- http://www.sohu.com/a/238203727_100132865
>- https://www.8btc.com/article/92887
>- https://mp.weixin.qq.com/s/lM0p3ikVBdw1zE50IWtMZA
>- http://8btc.com/doc-view-399.html

## DAG
### 什么是DAG
DAG：Directed Acyclic Graph，中文意为“有向无环图”，DAG抛弃了传统区块链的“区块”这一概念，取而代之的是“单元”。
传统区块链和DAG的区别，简单的说：
>- 单元：区块链组成单元是Block（区块），DAG组成单元是TX（交易）；
>- 拓扑：区块链是由Block区块组成的单链，只能按出块时间同步依次写入，好像单核单线程CPU； DAG是由交易单元组成的网络，可以异步并发写入交易，好像多核多线程CPU；
>- 粒度：区块链每个区块单元记录多个用户的多笔交易，DAG每个单元记录单个用户交易。

<center>
<img src="https://upload-images.jianshu.io/upload_images/796321-fa58f376b01c7061.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" width="500">
</center>

### DAG发展现状
DAG系当前代表项目，最知名的无疑是DAG三架马车 —- IOTA、字节雪球、Nano（原来的Raiblocks）。

#### 1 IOTA
IOTA背后最主要的创新Tangle（纠缠），是一个基于DAG全新设计的分布式账簿结构。是一个既没有块(Block)也没有链(Chain)的区块链。在Tangle中，每一个节点代表的是一个交易。IOTA里没有区块的概念，也没有挖矿和矿工的概念，没有挖矿和矿工就代表没有交易费，整个网络的吞吐量（Throughput）也很高，这是IOTA的最吸引人的亮点之处

Tangle的核心原则与区块链一致，依旧是一个分布式的数据库、P2P网络，以及共识算法来验证交易。Tangle与传统区块链之间的主要区别，就是Tangle数据结构以及共识机制。

在IOTA里没有区块的概念，取而代之的是交易网络，每一个交易都会引用过去的两条交易记录Hash，这样前一交易会证明过去两条交易的合法性，以及间接证明再之前所有交易的合法性。

这样，整个网络都参与交易合法性的验证，而不像传统区块链，只有全网中的矿工（或PoS的权益所有人）这样少量节点来验证交易合法性。因此，IOTA的共识就是它自身内化特性，可以使它在没有交易费用的情况下进行规模化使用。IOTA 中不再有区块的概念，共识的最小单位是交易。

The Tangle另外一个强大之处，就是可以随意的让交易从网络中剥离出来或者合并回去。这种离线异步处理的能力在物联网领域应用中尤为重要

IOTA定位在物联网应用区域：物联网。全球网络，其中无数设备在各自领域相互通信，工业设备如传感器或M2M，以及微支付.

IOTA目前的问题是：

>- MIT报告指出，IOTA使用了自己开发的哈希算法curl，但是curl算法的哈希值极易发生碰撞，于是就能伪造数字签名。
>- 因为共识是由全网交易确定的，那么理论上来说，如果有人能够产生1/3的交易量，他就可以将无效交易变成有效交易。另一方面，由于IOTA无手续费，所以没有矿工激励，IOTA面临着拒绝服务攻击和垃圾信息攻击可能，就像不收物业费的小区，靠业主自治很难扫清不法份子，
>- IOTA 引入闭源的中心化组件Coordinator来对全网交易进行检查（例如双花），如何有效移除Coordinator？ 并建立一个具有良性激励机制的分布式“Coordinator群体”，IOTA还没有给出解决方案。

#### 2 Byteball（字节雪球）
Byteball被称为区块链3.0的代表。具有DAG体系家族中最完善的应用生态，Byteball钱包内置丰富功能，包括类似Appstore模式的BotStore，自由开发者可以在上面自由开发应用，开发者非常活跃。

Byteball 在DAGCoin 的基础上, 创新性引入主链与见证人概念，鼓励验证多个父辈交易单元，形成一个随着交易增长、相互验证，安全性不断加强的数字签名Hash网络，Byteball创造性的发明了“主链”概念，也就是经过见证人认定的最短路径MC的Parents优选算法。主链创造了一个全网共识确定的交易时间序列，优雅的避免了双花问题。

Byteball中“见证人”(Witness)真正意义就是形成“共识机制”；12个“见证人”发布的交易单元，在理论上无限宽广的DAG并发交易网络中划出了一道确定性的交易时间序列。正是这道无限延伸基于时间的确定性交易序列，打造了Byteball中的主链，在宽广无序的有向无环哈希世界中形成了强健有序的唯一主干。基于见证人+主链的共识机制，双重支付等问题得到了轻松解决。

Byteball取消了区块链和工作量证明（POW）挖掘的概念，而是选择了DAG数据存储技术。 与基于传统区块链的加密货币相比，这具有强大的优势，Byteball 中的所有交易都是以加密方式相互关联的。 新产生交易将添加到tips交易单元后面。 这样让网络上的所有节点（用户）都参与验证交易，完全的分布式。

这不仅可以更快地验证付款，还可以让网络保持足够的分散。 避免在比特币中的一些问题：例如可能威胁网络的大型集中式矿池；同时Byteball通过收取存储在DAG网络的每字节数据存储费用，通过类似Gas机制减少网络上的SPAM垃圾信息。

有人说Byteball的Witness存在中心化依赖，这里也为Witness正名，在Byteball的Witness节点设计中，witness节点是高度安全的，仅仅能发出见证单元，无法接触交易， 所以Witness并不是矿工，Witness扮演的是WatchMan的角色，帮系统锚定交易发生时间顺序，没有留出作恶的空间； 另外Witenss 数量也可以根据需要设置和选择，并不局限于目前的12个见证人。

Byteball由于每个交易都有发起者的私钥签名，同时每笔交易都验证与引用从前发生的交易，以此编织成一个巨大的网络，对网络的篡改牵一发而动全身，同时不可能有人拥有全网所以用户的私钥，所以Byteball具备银行级最终确定性。

Byteball正在积极地尝试替代现有的数字货币，如比特币，或者更夸张的说，是去取代美元，欧元和所有其他法币，至少长期来看是这样。就像比特币要做的一样。

Byteball的问题是：由于主链算法和见证人发布频率有关系，交易确认的时间是不确定的。由于Byteball 基于关系数据库来存储数据，SQL语言过于紧耦合算法逻辑。 在一定程度上限制了Byteball目前的扩展能力和速度。

#### 3 NANO (XRB)
Nano（原名RaiBlocks XRB），是一种基于区块点阵(Block Lattice)结构的新型加密货币。

Nano是一个很有意思的项目，Nano创新性的采用了一个用户一条链的方式，只记录自己的交易，也只有自己可以修改记录，不与其它帐户共享数据，从而使所有的交易都可以并行执行，能提供秒级的交易速度和无限可扩展性，并且允许他们异步地更新到网络的其余部分，从而以极小的资源开销获得快速的交易确认。

Nano一个节点可以存贮所有账户的历史账本，也可以只存贮每个账户的最后修剪记录。当一笔交易发生的时候，发出金额的一方会生成一个send tx的区块，包含记录扣除的金额；而收款账户则生成receive tx区块记录对应获得的金额。交易数据的收发是可以异步进行的，所以就算同时有多笔金额汇入一个账户也没有问题，最终的金额是收到的金额的加法。如果接收方不在线也没关系，未到账的金额会单独标记，等到接收账户上线之后，这笔金额就会从未结算区打入接收区块，完成交易。

NANO使用了DPOS共识机制，账户可以指定代表为其投票，得票最多的代表将处理分叉，这个代表会将分叉广播到网络，并观察来自高权账户节点在固定时间内的投票接结果，以此来确定保留哪一个区块。DPOS可以保证区块的合理低能耗运行。NANO也使用到了POW机制，确认交易需要非常少的工作证明（PoW）。

NANO的问题：没有被充分测试、缺乏同行评议。共识算法可能有严重缺陷的风险。例如，如果没有足够的法定人数投票来解决网络冲突会发生什么？另一个大问题：如果NANO网络的某些部分长时间分离，当分离的网络重新加入时会发生什么？重新加入的网络是否会在不可避免发生的投票过程中瘫痪？