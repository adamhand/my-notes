# 14 | count(*)这么慢，我该怎么办？

随着表中的记录越来越多，select count(*) from t 语句的速度会变得越来越慢。下面就来分析一下count(*) 语句到底是怎样实现的，以及 MySQL 为什么会这么实现。然后，如果应用中有这种频繁变更并需要统计表行数的需求，业务设计上可以怎么做。

# count(*) 的实现方式

在不同的 MySQL 引擎中，count(*) 有不同的实现方式。

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；(如果加了 where 条件的话，MyISAM 表也是不能返回得这么快的。)
- 而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

为什么 InnoDB 不跟 MyISAM 一样，也把数字存起来呢？这是因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是**不确定**的。下面用一个算 count(*) 的例子解释一下。

假设表 t 中现在有 10000 条记录，存在三个用户并行的会话。

- 会话 A 先启动事务并查询一次表的总行数；
- 会话 B 启动事务，插入一行后记录后，查询表的总行数；
- 会话 C 先启动一个单独的语句，插入一行记录后，查询表的总行数。

下表中，从上到下是按照时间顺序执行的，同一行语句是在同一时刻执行的。

<div align="center">
<img src="">

`图 1 会话 A、B、C的执行流程`
</div>

可以看到，在最后一个时刻，三个会话 A、B、C 会同时查询表 t 的总行数，但拿到的结果却不同。**这和 InnoDB 的事务设计有关系，可重复读是它默认的隔离级别，在代码上就是通过多版本并发控制，也就是 MVCC 来实现的。每一行记录都要判断自己是否对这个会话可见，因此对于 count(*) 请求来说，InnoDB 只好把数据一行一行地读出依次判断，可见的行才能够用于计算“基于这个查询”的表的总行数。**

MySQL在执行count(*)的时候也是做了优化的。InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。**在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一**。

另外，在使用show table status 命令时，会有一个TABLE_ROWS 结果用于显示这个表当前有多少行，这个命令执行挺快的，但是它却不能用来代替count(*)，因为索引统计的值是通过采样来估算的。实际上，TABLE_ROWS 就是从这个采样估算得来的，因此它也很不准，官方文档说误差可能达到 40% 到 50%。

所以，这里就可以得到如下三点知识：

- MyISAM 表虽然 count(*) 很快，但是不支持事务；
- show table status 命令虽然返回很快，但是不准确；
- InnoDB 表直接 count(*) 会遍历全表，虽然结果准确，但会导致性能问题。

那么，怎么提高count(*)的速度呢？一个思路是，将操作记录表的行数存起来，查询是直接返回。

# 用缓存系统保存计数

可以使用缓存来存储计数，比如使用Redis，但是使用缓存存在两个问题：

- 丢失更新
- 缓存一致性
