# 02 | 日志系统：一条SQL更新语句是如何执行的？
---
下面从一个表的更新语句说起，谈一谈以条更新语句的执行流程是怎样的。

下面是这个表的创建语句，这个表有一个主键 `ID` 和一个整型字段 `c`：
```sql
mysql> create table T(ID int primary key, c int);
```
如果要将 `ID=2` 这一行的值加 `1`，`SQL` 语句就会这么写：
```sql
mysql> update T set c=c+1 where ID=2;
```
一条更新语句肯定也会走一遍查询语句的那一套流程。

- 执行语句前要先连接数据库，这是连接器的工作。
- 在一个表上有更新的时候，跟这个表有关的查询缓存会失效，所以这条语句就会把表 T 上所有缓存结果都清空。
- 接下来，分析器会通过词法和语法解析知道这是一条更新语句。
- 优化器决定要使用 ID 这个索引。
- 然后，执行器负责具体执行，找到这一行，然后更新。

与查询流程不一样的是，更新流程还涉及两个重要的日志模块：**redo log（重做日志）** 和 **binlog（归档日志）**。

# 重要的日志模块：redo log
先用一个例子说明`redo log`的作用。

在《孔乙己》这篇文章中，酒店掌柜有一个专门用来记录客人的赊账记录**粉板**。如果赊账的人不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的**账本**。

如果有人要赊账或者还账的话，掌柜一般有两种做法：

- 一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
- 另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。

**第一种做法**，掌柜必须先在密密麻麻的账本中找到赊账人的记录，然后将本次赊账数目写入到账本中，假如酒店的生意很忙，这种做法效率很低。**第二种做法**相对简单，只需要先在粉板上记录一下，等到不忙的时候再根据粉板的记录将每个人的赊账数量写入到账本中响应的位置上。

在`MySQL`中，**写账本**的操作就对应着写磁盘；**写粉板**的操作就对应着写日志。`MySQL`总是先写日志，然后再写磁盘，这种技术叫做`WAL`，的全称是 `Write-Ahead Logging`，即**预写日志**。

具体来说，当有一条记录需要更新的时候，`InnoDB` 引擎就会先把记录写到 `redo log`（粉板）里面，并更新内存，这个时候更新就算完成了。同时，`InnoDB` 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。

但是如果`redo log`不够用，`MySQL`就会将一部分`redo log`先更新到磁盘上，腾出一部分空间。

`InnoDB` 的 `redo log` 是固定大小的，比如可以配置为一组 `4` 个文件，每个文件的大小是 `1GB`，那么这块“粉板”总共就可以记录 `4GB` 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

<center>
<img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/innodb_redolog.jpg">
</center>

`write pos` 是当前记录的位置，一边写一边后移，写到第 `3` 号文件末尾后就回到 `0` 号文件开头。`checkpoint` 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。

`write pos` 和 `checkpoint`(所谓的 **“检查点”**) 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 `write pos` 追上 `checkpoint`，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 `checkpoint` 推进一下。

也就是说，`write pos`相当于一支笔，它走过的地方都被写满了，而`checkpoint`就像一个橡皮，它走过的地方都被擦除了。

有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

# 重要的日志模块：binlog
`MySQL` 整体来看，其实就有两块：一块是 `Server` 层，它主要做的是 `MySQL` 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。**`redo log` 是 `InnoDB` 引擎特有的日志，而 `Server` 层也有自己的日志，称为 `binlog`（归档日志）。**

这两种日志有以下三点不同。

- `redo log` 是 `InnoDB` 引擎特有的；`binlog` 是 `MySQL` 的 `Server` 层实现的，所有引擎都可以使用。
- **`redo log` 是物理日志**，记录的是“在某个数据页上做了什么修改”；**`binlog` 是逻辑日志**，记录的是这个语句的原始逻辑，比如“给 `ID=2` 这一行的 `c` 字段加 `1` ”。</p>
- `redo log` 是循环写的，空间固定会用完，不持久保存；`binlog` 是可以追加写入的，并且具备**归档**功能。“追加写”是指 `binlog` 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

于是，执行器和 `InnoDB` 引擎在执行这个简单的 `update` 语句时的内部流程就如下所述：

- 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。 
- 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。
- 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。
- 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。
- 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>

流程图如下所示，图中**浅色框表示是在 `InnoDB` 内部执行的**，**深色框表示是在执行器中执行的**：
<center>
<img src="https://raw.githubusercontent.com/adamhand/LeetCode-images/master/updata_flow.png">
</center>

可以看到，将 `redo log` 的写入拆成了两个步骤：`prepare` 和 `commit`，这就是 **"两阶段提交"**。

# 两阶段提交
两阶段提交是解决分布式事务的一种协议，具体过程不再赘述。

这里的两阶段提交并不涉及分布式事务，当然`mysql`把它称之为内部`xa`事务（`xa`是指由 `X/Open` 组织提出的分布式事务处理的规范，使用两阶段协议来管理分布式事务），与之对应的还有一个外部`xa`事务。

**内部`xa`事务**主要是`mysql`内部为了保证`binlog`与`redo log`之间数据的一致性而存在的；

**外部`xa`事务**则是指支持多实例分布式事务，这个才算是真正的分布式事务。

根据上图所示，两阶段提交流程如下：

- `prepare`阶段。这个阶段会写`redo log`，`binlog`不做任何操作。（至于`redo log`写完之后落不落盘，可以根据设置`innodb_flush_log_at_trx_commit`参数的值来进行选择，具体可参见后面的“补丁”）。
- `commit`阶段。如果`redo log`写成功，就会进入这个阶段，在这个阶段会写`binlog` 。如果`binlog`也写成功，就会执行`commit`操作，提交事务。

然后，结合几种场景来分析下二阶段提交是如何做到两个日志一致的：

- `prepare`阶段，`redo log`写完前，`mysqld crash`
- `commit`阶段，`redo log`写完后，`binlog`写完前，`mysqld crash`
- `commit`阶段，`binlog`写完后，`mysqld crash`

第一种情况，由于`redo log`没写完，没有执行`commit`操作，重启后会根据`undo log`回滚事务</br>
第二种情况，重启后发现也没有`commit`操作，会回滚</br>
第三中情况，重启后虽然没有`commit`，但满足`prepare`和`binlog`完整，所以会`commit`。</br>

# 数据恢复
MYsql能够恢复到之前的任意状态，靠的是binlog。

前面所说，binlog 会记录所有的逻辑操作，并且是采用“追加写”的形式，同时系统会定期做整库备份。如果想将数据库恢复到之前的某个状态，可以这么做：

- 首先，找到最近的一次全量备份，从这个备份恢复到临时库；
- 然后，从备份的时间点开始，将备份的 binlog 依次取出来，重放到误删表之前的那个时刻。

这样临时库就跟误删之前的线上库一样了，然后可以把表数据从临时库取出来，按需要恢复到线上库去。

# 补丁
**两个参数：**

- `innodb_flush_log_at_trx_commit` 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数建议设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。
- `sync_binlog` 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数也建议设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。

**注意：**
`Redo log`不是记录数据页“**更新之后的状**态”，而是记录这个页 “**做了什么改动**”。

`Binlog`有两种模式，`statement` 格式的话是记`sql`语句， `row`格式会记录行的内容，记两条，更新前和更新后都有。

# 参考
[MySQL事务提交过程（二）](https://www.cnblogs.com/exceptioneye/p/5451976.html)